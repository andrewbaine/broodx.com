// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Paper = require("paper");
var Js_exn = require("rescript/lib/js/js_exn.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");

var NotPossible = /* @__PURE__ */Caml_exceptions.create("App.NotPossible");

var $$Window = {};

var Rectangle = {};

var View = {};

var Matrix = {};

var Point = {};

var Color = {};

var Segment = {};

function Make(R) {
  return {};
}

var Options = {};

var Rectangle$1 = {};

var Path = {
  Make: Make,
  Options: Options,
  Rectangle: Rectangle$1
};

var Paper$1 = {
  Rectangle: Rectangle,
  View: View,
  Matrix: Matrix,
  Point: Point,
  Color: Color,
  Segment: Segment,
  Path: Path
};

function slope(b, a) {
  return (b.y - a.y) / (b.x - a.x);
}

function midpoint(factorOpt, a, b) {
  var factor = factorOpt !== undefined ? factorOpt : 0.5;
  return a.add(b.subtract(a).multiply(factor));
}

function divide(p1, p2) {
  var match = p1.x < p2.x ? [
      p1,
      p2
    ] : [
      p2,
      p1
    ];
  var p2$1 = match[1];
  var p1$1 = match[0];
  var x1 = p1$1.x;
  var y1 = p1$1.y;
  var x2 = p2$1.x;
  var y2 = p2$1.y;
  var bounds = Paper.view.bounds;
  var width = bounds.width;
  var height = bounds.height;
  var match$1 = x2 < x1 ? [
      p2$1,
      p1$1
    ] : [
      p1$1,
      p2$1
    ];
  if (x1 === x2) {
    return new (Paper.Path.Rectangle)(new Paper.Point(0, 0), new Paper.Point(x1, height));
  }
  if (y2 === y1) {
    return new (Paper.Path.Rectangle)(new Paper.Point(0, 0), new Paper.Point(width, y1));
  }
  var m = slope(match$1[1], match$1[0]);
  var b = (y2 - m * x2 + (y1 - m * x1)) / 2;
  var yy = m * width + b;
  var xIntercept = - (b / m);
  var heightIntercept = (height - b) / m;
  var segments;
  if (b < 0) {
    segments = yy < 0 ? Js_exn.raiseError("impossible") : (
        yy < height ? [
            new Paper.Point(xIntercept, 0),
            new Paper.Point(width, 0),
            new Paper.Point(width, yy)
          ] : [
            new Paper.Point(0, 0),
            new Paper.Point(xIntercept, 0),
            new Paper.Point(heightIntercept, height),
            new Paper.Point(0, height)
          ]
      );
  } else if (b < height) {
    segments = yy < 0 ? [
        new Paper.Point(0, 0),
        new Paper.Point(0, b),
        new Paper.Point(xIntercept, 0)
      ] : (
        yy < height ? [
            new Paper.Point(0, b),
            new Paper.Point(0, 0),
            new Paper.Point(width, 0),
            new Paper.Point(width, yy)
          ] : [
            new Paper.Point(0, height),
            new Paper.Point(0, b),
            new Paper.Point(heightIntercept, height)
          ]
      );
  } else if (yy < 0) {
    segments = [
      new Paper.Point(0, 0),
      new Paper.Point(xIntercept, 0),
      new Paper.Point(heightIntercept, height),
      new Paper.Point(0, height)
    ];
  } else if (yy < height) {
    segments = [
      new Paper.Point(heightIntercept, height),
      new Paper.Point(width, yy),
      new Paper.Point(width, height)
    ];
  } else {
    throw {
          RE_EXN_ID: NotPossible,
          Error: new Error()
        };
  }
  return new Paper.Path({
              segments: segments
            });
}

function reflection(path, a, b) {
  var p2 = path.clone();
  if (b.y === a.y) {
    p2.segments.forEach(function (segment) {
          var point = segment.point;
          point.y = 2 * a.y - point.y;
        });
  } else if (b.x === a.x) {
    p2.segments.forEach(function (segment) {
          var point = segment.point;
          point.x = 2 * a.x - point.x;
        });
  } else {
    var m = slope(b, a);
    var reflectionMatrix = new Paper.Matrix(1 - Math.pow(m, 2.0), 2 * m, 2 * m, Math.pow(m, 2) - 1, 0, 0).scale(1 / (1 + Math.pow(m, 2)));
    p2.translate(a.multiply(-1));
    p2.transform(reflectionMatrix);
    p2.translate(a);
  }
  return p2;
}

Paper.install(window);

Paper.setup("myCanvas");

window.onload = (function (param) {
    var segments = [
      new Paper.Point(100, 100),
      new Paper.Point(100, 100 + 400),
      new Paper.Point(100 + 400, 100 + 400),
      new Paper.Point(100 + 400, 100)
    ];
    if (segments.length !== 4) {
      throw {
            RE_EXN_ID: "Match_failure",
            _1: [
              "App.res",
              230,
              6
            ],
            Error: new Error()
          };
    }
    var fillColor = new Paper.Color(0.9);
    var strokeColor = new Paper.Color(0.0);
    var options = {
      segments: segments,
      fillColor: fillColor,
      strokeColor: strokeColor,
      closed: true
    };
    new Paper.Path(options);
    var front = new Paper.Path({
          segments: segments,
          fillColor: fillColor,
          strokeColor: strokeColor,
          closed: true
        });
    var p1 = new Paper.Point(400.0, 200.0);
    var p2 = new Paper.Point(600, 300);
    reflection(front, p1, p2);
  });

exports.NotPossible = NotPossible;
exports.$$Window = $$Window;
exports.Paper = Paper$1;
exports.slope = slope;
exports.midpoint = midpoint;
exports.divide = divide;
exports.reflection = reflection;
/*  Not a pure module */
